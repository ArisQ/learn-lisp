#+PROPERTY: header-args:scheme :tangle scheme-primer.scm

* [[https://files.spritely.institute/papers/scheme-primer.html][Scheme Primer]]

guile + emacs + geiser-guile

** Hello Scheme
#+begin_src scheme :results output
(display "Hello world!\n")
#+end_src

#+RESULTS:
: Hello world!

** Variables and procedures

*** define

#+begin_src scheme
(define (greet name)
  (string-append "Hello " name "!"))

(greet "Samantha")
#+end_src

#+RESULTS:
: Hello Samantha!

*** lambda

#+begin_src scheme
((lambda (name)
   (string-append "Hello " name "!"))
 "Horace")
#+end_src

#+RESULTS:
: Hello Horace!

*** let

#+begin_src scheme
(let ((name "Horace"))
   (string-append "Hello " name "!"))
#+end_src

#+RESULTS:
: Hello Horace!

*** let*

#+begin_src scheme
(let* ((name "Horace")
	  (greeting (string-append "Hello " name "!")))
  greeting)
#+end_src

#+RESULTS:
: Hello Horace!

*** variadic arguments

dot notation

#+begin_src scheme :results output
(define (chatty-add chatty-name . nums)
        (format #t "<~a> 求和结果为 ~a!\n"
                chatty-name (apply + nums)))
(chatty-add "Chester" 2 4 8 6)
#+end_src

#+RESULTS:
: <Chester> 求和结果为 20!

*** optional and keyword arguments

#+begin_src scheme :results output
(define* (shopkeeper thing-to-buy
                     #:optional (how-many 1)
                     (cost 20)
                     #:key (shopkeeper "Sammy")
                     (store "Plentiful Great Produce"))
  (format #t "You walk into ~a, grab something from the shelves,\n" store)
  (display "and walk up to the counter.\n\n")
  (format #t "~a looks at you and says, " shopkeeper)
  (format #t "~a ~a, eh? That'll be ~a coins!'\n" how-many thing-to-buy
          (* cost how-many)))

(shopkeeper "apples")
(display "\n==========\n")
(shopkeeper "bananas" 10 28)
(display "\n==========\n")
(shopkeeper "screws" 3 2
            #:shopkeeper "Horace"
            #:store "Horace's Hardware")
#+end_src

#+RESULTS:
#+begin_example
You walk into Plentiful Great Produce, grab something from the shelves,
and walk up to the counter.

Sammy looks at you and says, 1 apples, eh? That'll be 20 coins!'

==========
You walk into Plentiful Great Produce, grab something from the shelves,
and walk up to the counter.

Sammy looks at you and says, 10 bananas, eh? That'll be 280 coins!'

==========
You walk into Horace's Hardware, grab something from the shelves,
and walk up to the counter.

Horace looks at you and says, 3 screws, eh? That'll be 6 coins!'
#+end_example

*** multiple return values
:PROPERTIES:
:header-args:scheme: :session **multi-return-value**
:END:

#+begin_src scheme
(define (add-and-multiply x y)
  (values (+ x y)
          (* x y)))

(add-and-multiply 2 8)
#+end_src

#+RESULTS:
: 10
: 16

#+begin_src scheme :results output
(define-values (sum product)
  (add-and-multiply 3 10))

(format #t "sum=~a product=~a~%" sum product)
#+end_src

#+RESULTS:
: sum=13 product=30



** Conditionals and predicates
*** ~string?~
#+begin_src scheme
(values
 (string? "apple")
 (string? 128)
 (string? 'apple))
#+end_src

#+RESULTS:
: #t
: #f
: #f

*** if
#+begin_src scheme
(define (string-enthusiast obj)
  (if (string? obj)
      "Oh my gosh you gave me A STRING!!!"
      "That WASN'T A STRING AT ALL!! MORE STRINGS PLEASE!"))

(string-enthusiast "carrot")
#+end_src

#+RESULTS:
: Oh my gosh you gave me A STRING!!!

*** comparison

#+begin_src scheme
(values
 (> 8 9)
 (< 8 9)
 (> 8 8)
 (>= 8 8))
#+end_src

#+RESULTS:
: #f
: #t
: #f
: #t

#+begin_src scheme :results value list
(define (goldilocks n smallest-ok biggest-ok)
  (if (< n smallest-ok)
      "Too small!"
      (if (> n biggest-ok)
          "Too big!"
          "Just right!")))

;; 多值返回string时，org-babel只显示了一个
(list
 (goldilocks 3 10 20)
 (goldilocks 33 10 20)
 (goldilocks 12 10 20))
#+end_src

#+RESULTS:
- Too small!
- Too big!
- Just right!


*** cond

#+begin_src scheme :results value list
(define (goldilocks n smallest-ok biggest-ok)
  (cond
   ((< n smallest-ok) "Too small!")
   ((> n biggest-ok) "Too big!")
   (else "Just right!")))

;; 多值返回string时，org-babel只显示了一个
(list
 (goldilocks 3 10 20)
 (goldilocks 33 10 20)
 (goldilocks 12 10 20))
#+end_src

#+RESULTS:
- Too small!
- Too big!
- Just right!
  
*** ~equal?~ and ~eq?~
#+begin_src scheme
(define a-list (list 1 2 3))
(define b-list (list 1 2 3))

(values
 (equal? a-list a-list)
 (equal? a-list b-list)
 (eq? a-list a-list)
 (eq? a-list b-list))
#+end_src

#+RESULTS:
: #t
: #t
: #t
: #f

*** other than ~#f~ is true

#+begin_src scheme
(define (fruit-sleuth fruit basket)
  (if (member fruit basket)
	  "Found the fruit you're looking for!"
	  "No fruit found! Gadzooks!"))
(define fruit-basket '(apple banana citron))

(values
 (member 'b '(a b c))
 (fruit-sleuth 'banana fruit-basket)
 (fruit-sleuth 'pineapple fruit-basket))
#+end_src

#+RESULTS:
: (b c)
: "Found the fruit you're looking for!"
: "No fruit found! Gadzooks!"

** List and "cons"
*** list

#+begin_src scheme
(values
 0
 (list 1 2 "cat" 33.8 'foo)
 '(1 2 "cat" 33.8 foo)
 '(foo 'bar '''baz)
 '()
 (null? '()) ;; nil
 (cons 'a '())
 (cons 'a (cons 'b (cons 'c '())))
 (list 'a 'b 'c)
 '(a b c)
 (cons 'a 'b) ;; dotted list
 (cons 'a (cons 'b '()))
'(a . b)
'(a b))
#+end_src

#+RESULTS:
#+begin_example
0
(1 2 "cat" 33.8 foo)
(1 2 "cat" 33.8 foo)
(foo (quote bar) (quote (quote (quote baz))))
()
#t
(a)
(a b c)
(a b c)
(a b c)
(a . b)
(a b)
(a . b)
(a b)
(+ 1 2 (- 8 4))
#+end_example

*** ~car~ & ~cdr~

#+begin_src scheme
(values
 (car '(a b c))
 (cdr '(a b c))
 (car (cdr '(a b c)))
 )
#+end_src

#+RESULTS:
: a
: (b c)
: b

*** quote

#+begin_src scheme
(values
 0
 '(+ 1 2 (- 8 4))
 'foo
 (quote foo)
 '(lambda (x) (* x 2))
 (quote (lambda (x) (* x 2))))
#+end_src

#+RESULTS:
: 0
: (+ 1 2 (- 8 4))
: foo
: foo
: (lambda (x) (* x 2))
: (lambda (x) (* x 2))

*** alists (association lists)

#+begin_src scheme
(define animal-noises
  '((cat . meow)
    (dog . woof)
    (sheep . baa)))
(values
 animal-noises
 (assoc 'cat animal-noises)
 (assoc 'alien animal-noises))
#+end_src

#+RESULTS:
: ((cat . meow) (dog . woof) (sheep . baa))
: (cat . meow)
: #f

*** quasiquote

#+begin_src scheme
(define (cat-years years)
  (cond
   ((<= years 1) (* years 15))
   ((<= years 2) (+ 15 (* 9 (- years 1))))
   (else (+ 24 (* 4 (- years 2))))))

(define (cat-entry name age)
  `(cat (name ,name)
        (age ,age)
        (cat-years-age ,(cat-years age))))

(values
 0
 (cat-entry "Missy Rose" 16)
 (cat-entry "Kelsey" 22))
#+end_src

#+RESULTS:
: 0
: (cat (name "Missy Rose") (age 16) (cat-years-age 80))
: (cat (name "Kelsey") (age 22) (cat-years-age 104))

** Closures

#+begin_src scheme
(define (make-goldilocks smallest-ok biggest-ok)
  (define (goldilocks n)
    (cond
     ((< n smallest-ok) "Too small!")
     ((> n biggest-ok) "Too big!")
     (else "Just right!")))
  goldilocks)

(define goldi
  (make-goldilocks 10 30))

(values
 #t
 (goldi 3)
 (goldi 33)
 (goldi 12))
#+end_src

#+RESULTS:
: #t
: "Too small!"
: "Too big!"
: "Just right!"


** Iteration & recursion
*** map
#+begin_src scheme
(define (symbol-length sym)
  (string-length (symbol->string sym)))

(values
 (string-length "cat")
 (string-length "gorilla")
 (map string-length '("cat" "dog" "gorilla" "salamander"))
 (map symbol-length '(basil oregano parsley thyme))
 (map (lambda (str)
        (string-append "I just love " (string-upcase str) "!!!"))
      '("straberries" "bananas" "grapes")))
#+end_src

#+RESULTS:
: 3
: 7
: (3 3 7 10)
: (5 7 7 5)
: ("I just love STRABERRIES!!!" "I just love BANANAS!!!" "I just love GRAPES!!!")

*** for-each

#+begin_src scheme :results output
(for-each (lambda (str)
            (display
             (string-append "I just love " (string-upcase str) "!!!\n")))
          '("ice cream" "fudge" "cookies"))

(define (my-for-each proc lst)
  (if (eq? lst '())
      'done
      (let ((item (car lst)))
        (proc item)
        (my-for-each proc (cdr lst)))))

(my-for-each (lambda (str)
               (display
                (string-append "I also love " (string-upcase str) "!!!\n")))
             '("ice cream" "fudge" "cookies"))
#+end_src

#+RESULTS:
: I just love ICE CREAM!!!
: I just love FUDGE!!!
: I just love COOKIES!!!
: I also love ICE CREAM!!!
: I also love FUDGE!!!
: I also love COOKIES!!!

*** build tree by recursion

#+begin_src scheme :results output
(define (build-tree depth)
  (if (= depth 0)
      '(0)
      (list depth
            (build-tree (- depth 1))
            (build-tree (- depth 1)))))

(define (fill-indent n)
  (if (= n 0)
      ""
      (string-append " " (fill-indent (- n 1)))))

(define (dump-tree tree indent)
  (if (= (length tree) 1)
      (format #f "(~a)" (car tree))
      (let* ((node-str (format #f "(~a " (car tree)))
             (sub-indent (+ indent (string-length node-str))))
        (string-append
         node-str
         (dump-tree (car (cdr tree)) sub-indent)
         (format #f "\n")
         (fill-indent sub-indent)
         (dump-tree (car (cdr (cdr tree))) sub-indent)
         (format #f ")")))))

(display (dump-tree (build-tree 3) 0))
#+end_src

#+RESULTS:
: (3 (2 (1 (0)
:          (0))
:       (1 (0)
:          (0)))
:    (2 (1 (0)
:          (0))
:       (1 (0)
:          (0))))

